# Docker - Storage

컨테이너에서 생성되는 모든 파일은 컨테이너 쓰기 레이어에 저장된다. 이 말은,

* 컨테이너가 존재하지않을 때 데이터는 영속적이지 않다.
* 컨테이너 바깥으로 데이터를 꺼내기 번거롭다.
* 컨테이너 쓰기 레이어는 컨테이너가 띄워진 호스트 머신과 결합도가 높아 다른곳으로 이동시키기 어렵다.
* 컨테이너 쓰기 레이어를 사용하면 스토리지드라이버가 필요하다. 스토리지드라이버는 리눅스7 커널을 통해 union fileSystem을 제공하는데, 이게 별로다.
	* 도커 볼륨이 더 좋다고 함.

# 도커의 마운트

![type-of-mount](./_resources/types-of-mounts.png)

도커는 세가지 종류의 마운트를 제공하며, 컨테이너 입장에서 마운트 종류는 달라도 저장된 데이터는 동일하게 취급된다.

* **Volumes** : 도커에 의해 관리되는 호스트 파일시스템에 저장된다. (리눅스 기준 `/var/lib/docker/volumes`). 도커 프로세스가 아닌 경우 볼륨 내 파일시스템을 수정할 수 없다. 가장 좋은 방법으로 소개한다.
* **Bind mounts**: 호스트 시스템에 어느경로든 마운트 지정하여 저장가능하다(중요 디렉터리도 지정 가능하다). 도커 프로세스가 아니라도 수정 가능하다.
* `tmpfs` **mounts** : 호스트 시스템 메모리에 저장된다. 파일 시스템에 쓰지(write)는 않기에 영속성은 없다.

## 사용법

### [볼륨](https://docs.docker.com/storage/volumes/)

* 볼륨을 생성한다

`docker volume create [생성 할 볼륨 이름]`

* 볼륨 정보를 조회한다.

```bash
$ docker volume create nginx-volume
$ docker volume inspect nginx-volume
[
    {
        "CreatedAt": "2023-01-28T14:21:17+09:00",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/home1/sys-var/lib/docker/volumes/nginx-volume/_data",
        "Name": "nginx-volume",
        "Options": {},
        "Scope": "local"
    }
]
```

* 컨테이너를 볼륨에 연결하여 생성한다. `-v` 옵션으로 `[볼륨 이름]:[연결할 컨테이너 디렉터리]`를 주면 볼륨과 연결 가능하다.

`docker run -d -p 8082:80 -v nginx-volume:/usr/share/nginx/html nginx`

* 볼륨은 호스트 디렉터리와 양쪽을 **동기화** 시키는 구조이다.
	* 호스트 디렉터리가 비어있고, 컨테이너 디렉터리에 파일이 있다면 호스트 디렉터리에 해당 파일이 동기화된다.
	* 호스트 디렉터리와 컨테이너 디렉터리에 동일한 파일이 있을때는 호스트 디렉터리 파일이 컨테이너에 덮어쓰기 된다.

### [바인드 마운트](https://docs.docker.com/storage/bind-mounts/)

* 호스트의 파일이나 디렉터리를 컨테이너에 마운트 시킨다.  `-v` 옵션으로 `[호스트 디렉터리 절대경로]:[연결할 컨테이너 디렉터리]`를 주면 바인드 마운트 된다.

`docker run -d -p 8081:80 -v /home1/irteam/html:/usr/share/nginx/html nginx`

* 바인드 마운트는 호스트 디렉터리의 내용을 그대로 컨테이너 디렉터리에 **덮어쓰기** 한다.
	* 컨테이너 디렉터리의 파일이 삭제될 수 있다.
* 볼륨에 비해 OS 디렉터리 구조에 의존적이라는 단점이 있다 (절대경로).

### [tmpfs 마운트](https://docs.docker.com/storage/tmpfs/)

* tmpfs 방식으로 마운트 시킨다(메모리에). `--tmpfs` 옵션을 주고 연결할 컨테이너 디렉터리를 주면 호스트 메모리와 연결된다.
  `docker run -d -p 8082:80 --tmpfs /usr/share/nginx/html nginx`

## Volumes vs. Bind mounts vs. `tmpfs` mounts

* 볼륨과 바인드 마운트가 가장 많이 쓰이는데 왠만하면 볼륨을 쓰라고 더 좋다고 한다.
* 볼륨은
	* 여러 컨테이너에 공유되어 사용할 수 있다.
	* 호스트 머신의 디렉터리나 파일구조가 보장되지않아도 사용가능하다. 도커에서 관리하기에 다 맞춰줌.
	* 백업, 복구, 다른 도커 호스트로 마이그레이션 할때 볼륨 디렉터리만 가져오면 쉽게 가능하다.
	* Docker Desktop에서 볼륨을 사용하면 볼륨은 Linux VM에 저장되었기에 호스트보다 더 적은 latency의 IO와 높은 처리량을 보여준다.
		* 로우레벨에서 동작하기에 더 성능이 좋다

* 바인드 마운트는
	* 여러 컨테이너에 공유되어 사용할 수 있다.
	* 호스트 장비의 설정 파일도 컨테이너와 공유할 수 있다는 점이 장점이다.
		* 예를들어 컨테이너는 DNS resolution을 위한 `/etc/resolve.conf` 파일을 바인드마운트로 공유하여 해석한다.

* `tmpfs` mount와 컨테이너 쓰기 레이어의 차이는 컨테이너에 할당된 리소스를 사용하는가의 차이이다.
	* 한계도 명확하다. 두 컨테이너에 동시에 마운트 될 수도 없으며, 리눅스에서 도커를 실행할 때만 사용가능하다.
	* `tmpfs` mount는 데이터 영속화를 원치 않을 때 사용하면 된다.
	* 하나의 예시로 보안적으로 저장 시 이슈가 되는 데이터가 있는데 리소스도 꽤 차지해서 볼륨을 사용해야하는 경우이다.
	* 캐시와 성격이 비슷해서 그런 경우에 사용하자.

* 호스트 디렉터리와 컨테이너 디렉터리를 바인드 마운트하거나, 동일파일이 있는 상태에서 볼륨은 연결하면 덮어쓰기된다고 사실 obscured 되는것이다.
	* 볼륨, 바인드 마운트가 해제되면 컨테이너의 기존 파일들로 다시 접근가능하다.
